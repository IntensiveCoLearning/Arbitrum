---
timezone: Asia/Shanghai
---

> 请在上边的 timezone 添加你的当地时区，这会有助于你的打卡状态的自动化更新，如果没有添加，默认为北京时间 UTC+8 时区
> 时区请参考以下列表，请移除 # 以后的内容

timezone: Pacific/Honolulu # 夏威夷-阿留申标准时间 (UTC-10)

timezone: America/Anchorage # 阿拉斯加标准时间 (UTC-9)

timezone: America/Los_Angeles # 太平洋标准时间 (UTC-8)

timezone: America/Denver # 山地标准时间 (UTC-7)

timezone: America/Chicago # 中部标准时间 (UTC-6)

timezone: America/New_York # 东部标准时间 (UTC-5)

timezone: America/Halifax # 大西洋标准时间 (UTC-4)

timezone: America/St_Johns # 纽芬兰标准时间 (UTC-3:30)

timezone: America/Sao_Paulo # 巴西利亚时间 (UTC-3)

timezone: Atlantic/Azores # 亚速尔群岛时间 (UTC-1)

timezone: Europe/London # 格林威治标准时间 (UTC+0)

timezone: Europe/Berlin # 中欧标准时间 (UTC+1)

timezone: Europe/Helsinki # 东欧标准时间 (UTC+2)

timezone: Europe/Moscow # 莫斯科标准时间 (UTC+3)

timezone: Asia/Dubai # 海湾标准时间 (UTC+4)

timezone: Asia/Kolkata # 印度标准时间 (UTC+5:30)

timezone: Asia/Dhaka # 孟加拉国标准时间 (UTC+6)

timezone: Asia/Bangkok # 中南半岛时间 (UTC+7)

timezone: Asia/Shanghai # 中国标准时间 (UTC+8)

timezone: Asia/Tokyo # 日本标准时间 (UTC+9)

timezone: Australia/Sydney # 澳大利亚东部标准时间 (UTC+10)

timezone: Pacific/Auckland # 新西兰标准时间 (UTC+12)

---

Yi

1. 各位老师好，我是 Yi , 两年经验的后端开发(Java向)，很高兴认识大家
2. 个人时间相对充裕，有接触新知识的欲望，我认为我可以完成此次学习

## Notes

<!-- Content_START -->

### 2024.12.10

>Ethereum:
>
>Ethereum 吞吐量低的原因
>
>1. 每个节点都会参与处理历史的每一笔交易
>2. 为了做到去中心化，Ethereum 需要大多数人可以运行（对用户硬件配置和软件资源的要求比较低）
>
>

>Arbitrum（Rollup、Arbitrum One）
>
>简介
>
>Arbitrum 是为了解决以太坊 Tps 低的问题而开发的项目，它通过 **Rollup** 协议在以太坊之上创建了一个交易层。
>
>最终 Arbitrum 会将将交易数据打包发布到以太坊，保证了项目的安全性和去中心化的同时，提高了处理速度。
>
>
>
>特点
>
>1. 更高的吞吐量（更快的交易确认）
>2. 更低的费用
>
>
>
>安全性
>
>从简介中来看，只要有一个诚实的用户，就能证明任意数量的欺诈者（此处推测，验证器可能是利用 Ethereum 的账本机制，来回溯真实的交易记录）
>
>
>
>兼容性
>
>从用户的角度，基本上与使用 Ethereum 没有区别；
>
>从开发人员的角度，工具和库都兼容，而且在保持兼容性的前提下，支持用 Rust、C++ 来编写高性能的智能合约

>AnyTrust（Nova）
>
>Rollup 链的所有数据放在 L1 链上管理，而 AnyTrust 链的数据，放在链下管理，在遇到攻击时，AnyTrust 链会恢复到 Rollup 的模式，但是这里需要至少 2 名成员是诚实的。
>
>数据放在链下，吞吐量会进一步提高，用户费用也会显著减低，适合高吞吐量且不需要完全去中心化的应用

### 2024.12.11

>交互式证明:
>
>争议双方参加一个由 L1 合约引导的回合制协议，双方在链下进行争议的解决
>
>如果该争议涉及了 N 个执行步骤，一方曝光出 2 个涉及 N/2 的断言，然后让对方选择一个挑战，这样争议规模就缩小了一半；重复以上步骤，直至争议缩减到单个执行步骤，此时再到链上按此步骤执行来解决争议
>
>
>
>重执行证明:
>
>让一个 Rollup 区块在区块内每一笔交易上做断言，L1 引导合约模拟执行整个交易流程，来验证结果

>交互式证明的优势:
>
>1. 效率更高
>
>乐观情况下，一个区块只需要包含一个断言，空间占用小，节省成本。
>
>悲观情况下，引导合约只需要执行一个步骤即可验证争议，速度快
>
>2. 更高的交易级 gas limit
>
>交互式证明的 gas limit 相较于 Ethereum 要大得多，重执行证明受限于 Ethereum 的 gas limit，可能没办法在一笔交易内模拟执行完
>
>3. L2 上的合约大小没有限制
>
>交互式证明不需要为 L2 合约在 Ethereum 上创建对应合约，所以不受限制；重执行模式的 gas limit 必须小于 Ethereum 合约的 gas limit（因为模拟执行的 gas limit 消耗更大）
>
>4. 灵活性
>
>举个例子，EVM 中新增指令，必要的功能无非是能在以太坊上验证一个单步执行的证据。而重执行模式就严格受限于 EVM

>Arbitrum 欺诈证明：
>
>1. 从全局状态开始，进行二分查找，将争议缩小至单个区块
>2. 在区块内部调用 ChallengeExecution，同样二分查找判定，将争议缩小至单个步骤
>3. 提供证明数据，调用 oneStepProveExecution，验证结果
>
>争议以两个段作为开始，此时假设双方同意某一段的正确性，对第二段存在分歧；下一轮中，选择第一段作为起始，结尾位置在上一轮第二段之前，此时就将争议缩小了一部分；重复以上流程，直至争议缩减至单个步骤，解决争议。（每一轮中，双方轮流决定挑战的位置）
>
>赢得挑战后，挑战方不能做出任何有效行动，最终会因为超时而失败，这样做是为了预防，如果挑战被错误解决，就有时间通过合约升级来诊断和修复错误



### 2024.12.12

>Arbitrum Classic:
>
>首次在 Arbitrum One 链主网上发布的技术
>
>
>
>Arbitrum Nitro:
>
>Arbitrum 最新的技术，是 Arbitrum Classic 的升级
>
>
>
>相同点:
>
>两者都创建了一个尽可能接近 EVM 的执行环境，作为 L2;
>
>通过以太坊本身简洁的欺诈证明来保证 L2 的安全性
>
>
>
>不同点:
>
>Classic 通过定制虚拟机（AVM）来实现，虚拟机上运行 ArbOs，可以模拟 EVM 的执行
>
>Nitro 通过 Go 语言实现逻辑，在欺诈证明的时候编译成 Wasm 来执行

>Nitro 的优势:
>
>1. 费用更低
>
>Classic 中，高级语言（solidity，vyper）会被转化为 EVM 字节码，然后 ArbOs 会将 EVM 字节码转换为相应的 AVM 指令在 L2 链上运行，这些 AVM 指令可以作为证明欺诈的输入。在交互式欺诈证明中，找到 AVM 中的一步证明，然后在 EVM 中执行
>
>Nitro 中，L2 链上运行的 Go 代码。Nitro 会定时生成类似 Ethereum 的区块，这些区块可以视为 Check Point。利用这点，将交互式欺诈分为 2 个阶段：首先将争议缩小到一个区块上，然后把该区块代码编译为 Wasm，再把争议缩小至 Wasm 指令。所以只能再发生争议时，才需要将 Go 编译成 Wasm 来证明欺诈。
>
>大多数正常情况下在 L2 链上使用 Go 代码来执行，仅在需要欺诈证明时编译成 Wasm 去 EVM 上证明欺诈，这种方式速度更快，性能更强，相应的，费用也就越低
>
>
>
>Arbitrum 交易的大部分费用都用于支付在 Ethereum 上发布数据的成本，所以如何压缩数据就非常关键。
>
>Classic 中，AVM 是为 Arbitrum 定制的虚拟机，压缩算法需要自定义并且手动实现，有很高的技术风险
>
>Nitro 中，使用 Go 代码，可以使用成熟的压缩库，显著降低发布交易到 L1 上的成本
>
>
>
>
>
>2. 兼容性更强
>
>ArbOs 虽然能处理所有的 EVM 操作码，但还是有些逻辑与 EVM 不同，比如：gas 费的单位不同导致 L1 上的合约必须经过修改逻辑之后才能发布到 L2 上，很不方便；
>
>Nitro 用 Go 模拟 Ethereum 运行，基本一比一复刻
>
>
>
>
>
>3. 简洁性
>
>AVM 是定制的，没有对应的高级语言，开发成本比较高；
>
>Nitro 用 Wasm 作为 L2 的虚拟机，可以用高级语言进行编写合约，代码要精炼、简单很多，开发成本更低，安全性也更加有保障

### 2024.12.13

>AnyTrust:
>
>AnyTrust 是 Nitro 的技术变式，它通过最小信任假设来降低交易成本，依靠链下数据可用性委员会来存储数据和证明欺诈
>
>
>
>数据可用性委员会:
>
>AnyTrust 模式下，用户将交易发布到 Sequencer 之后，Sequencer 会将数据发到链下委员会存储，委员会将为批量的交易数据签署可用性证书（DACerts），只有 DACerts 会被上传到主网的 inbox 合约，进一步降低了发送到主网的数据大小。而且委员会公开了查询接口，允许通过证书的 Hash 获取数据批次。
>
>当需要获取交易数据的时候，从 inbox 合约中获取上传的 hash 值，通过查询接口，就可查询到交易数据。Anytrust 方案在一定程度上牺牲了去中心化特性（也牺牲了一定安全性），依赖中心化组织保证数据的正确性
>
>
>
>Nova:
>
>Nova 是基于 AnyTrust 技术搭建的新链，专为游戏、社交应用程序这种对成本和性能更敏感的应用而设计。	Nova 支持了 2 种数据发布方式，一种是以 Calldata 的形式发布完整数据，一种是发布 DACert 的方式。
>
>Nova 的定序器将完整的数据集同时发送给所有 DAC 委员会的成员，委员会签名后把带有签名的证明返回给定序器，定序器收集到足够多的证明就能将它们聚合并创建有效的数据可用性证明（DACert），然后把 DACert 发布到主网。如果定序器没有收集到足够多的证明，Nova 会回退到 Rollup 模式（以 Calldata 形式发布数据到主网）。

>Orbit：
>
>Orbit 是一个开发框架，允许用户使用任何基于 Arbitrum Rollup 的 L2 网络作为结算层来创建和启动 L3 网络。借助 Arbitrum Orbit，用户可以在隐私、权限、费用代币、治理等方面定制自己的链。（L3 使得链上资源密集型应用成为可能。）
>
>
>
>BOLD：
>
>BOLD 是 Arbitrum 团队提出的无需许可验证机制，目的是最小化结算状态的延迟。
>
>目前对于乐观 Rollup 而言，普遍存在一周的挑战期，用户从 L2 提现到 L1 要等一周；挑战期内验证者如果发现提交上来的 L2 交易有问题，可以发起挑战。
>
>通过引入 BOLD 机制，一方面能实现验证的无需许可，更符合区块链去中心化的理念；另一方面，能实现最小化结算状态的延迟。BOLD 允许单个诚实的验证者在以太坊上与任意数量的对手进行争议时取胜，从而使 DDOS 攻击失效。
>
>
>
>Stylus：
>
>简言之，开发人员在 Arbitrum 上既能使用传统 Solidity 语言，又能使用 WASM 兼容的语言，如 Rust、C 和 C++ 等来构建应用程序。此外，Stylus 使 Dapps 的执行更加高效，显著地降低了 gas 成本。

### 2024.12.14

#### 工作机制

用户和合约将消息放入 inbox，链一次读取并处理一条消息，然后更新链上的状态。

执行是确定性的：链的行为由 inbox 里的内容唯一确定。因此，只要消息被放入 inbox，就可以从任何节点获取交易结果。

#### 工作理念

##### 排序，然后确定性执行

Sequencer 接收用户发来的交易，将交易放入有序序列中，然后发布该序列。

交易经过排序后，按顺序逐一通过状态转换函数运行。状态转换函数将链的当前状态（帐户余额、合约代码等）以及下一个交易作为输入，用输出的结果更改链上状态，有时会在 Nitro 链上发出新的 L2 区块。

由于协议不相信 Sequencer 不会将垃圾放入其序列中，因此状态转换函数将检测并丢弃序列中的任何无效交易。行为良好的 Sequencer 将过滤掉无效交易，这降低了成本，从而保持交易费用较低（但无论 Sequencer 在其 feed 中放入什么，Nitro 仍将正常工作）

状态转换函数是确定性的，它的行为仅取决于链的当前状态和下一个交易的内容。由于这种确定性，交易 T 的结果将仅取决于链的创世状态、序列中 T 之前的交易以及 T 本身。

因此，任何知道交易序列的人都可以自己计算状态转换函数——并且所有这样做的诚实方都保证获得相同的结果。这是 Nitro 节点运行的正常方式：获取交易序列，并在本地运行状态转换函数。这不需要共识机制。



Sequencer 的发布方式: 

1. 实时 feed：（软终结）

Sequencer 发布信息，订阅过的人都可以在交易排序时收到通知。Nitro 节点可以直接从 Sequencer 订阅信息，也可以从转发信息的中继处订阅。如果 Sequencer 是诚实的，它将按特定顺序记录交易。所有订阅人都可以使用收到的交易来运行状态转换函数，获取每笔交易的结果。这被称为交易的“软终结”；它之所以“软”，是因为它取决于 Sequencer 是否是诚实的



1. L1 上发布批量交易：（硬终结）

Sequencer 还在 L1 以太坊链上发布其序列。 Sequencer 会定期连接 feed 中的下一组交易，对其进行压缩（brotli算法），并将结果作为 calldata 发布在以太坊上。一旦这一批次的交易在以太坊上成功发布，它记录的第 2 层 Nitro 交易也将确定，并且交易的结果任何一方都清楚。这就是”硬终结“。

##### Geth 核心

Nitro 节点由三层构建：

1. 基础层为 Geth 的核心代码——Geth 模拟 EVM 合约的执行的代码、以及维护构成以太坊状态的数据结构的代码。Nitro 将此部分代码编译为一个库，并进行了一些小修改以添加必要的钩子。
2. 中间层 ArbOS 是定制软件，提供 L2 相关的附加功能
3. 顶层由节点软件组成，主要来自 Geth。它处理来自客户端的连接和传入的 RPC 请求，并提供操作与以太坊兼容的区块链节点所需的其他顶级功能。

##### 执行和证明分离

Nitro 通过使用相同的源代码进行执行和证明，但两种情况会选择不同的编译方式。

在编译 Nitro 节点软件时，使用普通的 Go 编译器。

在证明的时候，Go 编译器将状态转换函数的代码部分编译为 Wasm，并最终转换为 WAVM 的格式（修改版 Wasm）

##### Optimistic Rollup

略（前文已讲述）

### 2024.12.15

#### 全节点

Arbitrum 全节点通常位于 L2，和 Ethereum 全节点一样，保存链的状态，并提供与链交互的 Api

#### Sequencer

Sequencer 是特殊的全节点，有一定的权力控制交易顺序，所以 Sequencer 能立刻保证用户交易的结果，而无需等待以太坊上发生任何事情。

客户端与 Sequencer 的交互方式与它们与任何完整节点交互的方式完全相同。

##### 即时确认

如果没有 Sequencer，节点可以预测客户端交易的结果，但无法确定，因为它不知道交易在收件箱中的排序方式

Sequencer 有权为其客户端的交易分配收件箱队列中的位置，从而确保立即确定客户端交易的结果。

##### inbox、delayed inbox

只有 Sequencer 可以将新消息直接放入 inbox。Sequencer 用以太坊区块编号和时间戳标记它正在提交的消息。

其他任何人都可以提交消息，但非 Sequencer 节点提交的消息将被放入 delayed inbox，该队列由 L1 以太坊合约管理。

delayed inbox 中的消息将在那里等待，直到 Sequencer 将它们提取到 inbox 的末尾。

如果消息在 delayed inbox 中的时间超过最大延迟间隔，则任何人都可以强制将其提取到 inbox

##### 性质

目前在 Arbitrum One 上，Offchain Labs 运行了一组中心化的 Sequencer ，慢慢会过渡到去中心化的 Sequencer。Sequencer 不是单个中心化服务器，而是一个服务器委员会，只要委员会中有足够多的绝大多数成员是诚实的，Sequencer 就会建立公平的交易排序。



#### 跨链调用

##### L1 -> L2 直接调用

L1 合约可以直接调用 L2 合约，但操作只能是异步的，且收不到返回值

这种方法的优点是简单且延迟相对较低，缺点是无法确认 L2 交易是否成功。

如果 L1 成功，L2 失败，可能会造成损失

##### L1 -> L2 基于 ticket 的调用

L1 合约可以提交可重试的交易，如果交易失败，Nitro 将创建一个 ticketId 来标识失败的交易，之后任何人都可以调用 L2 上的特殊合约，提供 ticketId，重新执行交易

ps: L2 -> L1 的交易也适用这种方式



### 2024.12.16

#### DAO 宪法

##### 链的所有权

1. **链授权与治理**：ArbitrumDAO 授权使用 Arbitrum 技术创建并结算到以太坊的第 2 层链，每个授权链需通过 Arbitrum Improvement Proposal (AIP) 进行批准，并且每个 AIP 只能授权一条链。
2. **受控链与非受控链**：授权链分为受控链（由 $ARB 代币管理）和非受控链（不由 $ARB 代币管理）。无论是哪种类型，所有授权链都必须结算到以太坊或以太坊上。
3. **链所有者权限**：每条链有一个或多个“链所有者”，他们负责管理链的核心协议、代码和参数调整，包括升级合约和控制系统参数。
4. **第 3 层链**：使用 Arbitrum 技术结算到其他 ArbitrumDAO 批准链的第 3 层链不需要 ArbitrumDAO 的授权。
5. **安全委员会与所有者权利**：Arbitrum One 和 Arbitrum Nova 链的“所有者”特权已授予 ArbitrumDAO 和 Arbitrum 基金会的安全委员会。

##### DAO 提案和投票程序

ArbitrumDAO 提案和投票程序包括三个主要阶段：

1. **温度检查阶段（1周，推荐）**：提案在公共论坛上进行讨论，并通过快照投票进行初步审议，若未通过则不提交正式投票。
2. **正式 AIP 提交与投票呼吁（3天）**：提案正式提交至 Arbitrum One 上的治理合约，并通过 Tally 提供更多时间让社区进行讨论和投票。
3. **DAO 投票阶段（14-16天）**：DAO 成员在链上对提案进行正式投票，投票结果需满足两个条件才能通过：赞成票超过反对票，并且一定比例的可投票代币参与投票。

每个 AIP 提交时需提供详细的提案内容，包括摘要、动机、实施步骤、成本和时间表等。拒绝的提案可进行重新提交，需说明修改内容和重新提交的原因。

这些程序确保了 Arbitrum 的治理透明且富有社区参与，推动了网络的健康发展。

##### 安全理事会

**安全理事会** 是 ArbitrumDAO 的关键治理机构，由 12 名成员组成，负责执行紧急和非紧急行动，确保 ArbitrumDAO 宪法的遵守。其主要职责包括：

1. **紧急行动**：在链的安全性受到威胁时，执行紧急措施。必须获得 9 票支持，且必须发布透明度报告。
2. **非紧急行动**：执行常规软件升级或参数调整，需获得 9 票支持，并可绕过部分 AIP 流程加速决策。
3. **合约与位置**：安全理事会使用两个多重签名合约，一个在以太坊主网，另一个在 Arbitrum 治理链上。
4. **权力调整**：安全理事会的权限可以通过 ArbitrumDAO 提案（AIP）进行修改或取消。

安全理事会的主要作用是确保系统稳定与安全，且其权限受到 ArbitrumDAO 宪法的监管。

### 2024.12.17

##### 安全理事会选举

该选举流程描述了如何通过DAO治理选举安全理事会成员，确保选举透明、公平和合规。主要内容包括：

1. **成员组成**：安全理事会有12名成员，分为两组，每组6人，定期通过选举替换成员。
2. **选举周期**：

- - **候选人提名（T至T+7天）**：DAO成员可以宣布成为候选人。
  - **投票阶段（T+7至T+14天）**：DAO成员为候选人投票，且每个候选人需获得至少0.2%的支持。
  - **合规审查（T+14至T+28天）**：候选人接受合规审查，符合条件者进入正式选举。
  - **选举投票（T+28至T+49天）**：DAO成员投票选举最终成员，投票权重逐渐递减。

3. **选举规则**：

- - 投票权重自T+35天起递减。
  - 每个代币持有者只能为一个候选人投票。

1. **合规性**：候选人不得有利益冲突，避免单一实体控制理事会。
2. **免职程序**：安全理事会成员可以被免职，需获得10%可投票代币支持或至少5/6成员支持。
3. **规则修改**：DAO可以修改未来选举规则，但不能干预正在进行的选举。

该流程旨在确保选举公平、透明，并避免利益冲突或单一实体控制。

##### 数据可用委员会

在**Arbitrum Nova链**上，交易数据不在以太坊主网直接存储，而是由**数据可用性委员会**（DAC）成员发布并存储在专用的服务器上。委员会的主要任务是确保链上交易数据的可用性。

关键点包括：

1. **成员管理**：数据可用性委员会的成员由 **ArbitrumDAO** 批准的宪法 AIP 任命或罢免，确保治理过程的透明性和民主性。
2. **紧急替补机制**：如果成员被免职或辞职，**安全理事会**可在紧急情况下根据规则任命替补，确保委员会运作的连续性和稳定性。
3. **职责**：委员会保障Arbitrum Nova链的数据可用性，避免因单一故障点导致数据丢失，同时确保数据存储和处理的安全与透明。

此机制增强了Arbitrum Nova的去中心化特性，并通过透明的治理和紧急应对措施，提高了系统的可靠性和稳定性。

##### 社区价值观

Arbitrum的社区价值观强调以下几个核心原则：

1. **与以太坊对齐**：作为以太坊生态系统的一部分，Arbitrum与以太坊社区保持深厚联系，独立决策但积极参与其中。
2. **可持续性**：关注中长期目标，决策应优先考虑Arbitrum的长期健康与繁荣，而非短期利益。
3. **安全**：注重协议安全，特别是Arbitrum One的安全性应依赖于以太坊，并在更改时保持这一特性。
4. **社会包容性**：欢迎各类参与者，视差异为学习与发展的机会。
5. **技术包容性**：普通用户应能通过常规计算机系统参与Arbitrum协议。
6. **以用户为中心**：管理应以造福所有用户为核心目标。
7. **中立与开放**：促进开放创新、互操作性、用户选择和健康竞争，避免偏袒任何一方。

这些价值观旨在确保Arbitrum生态系统的长期健康、安全和公平。

### 2024.12.18

#### 如何发起提案

##### 前提条件

1. 通过 Snapshot 提交温度检查，以太坊地址至少需要 50w ARB
2. 通过 Tally 提交正式的链上提案，以太坊地址至少需要 100w ARB

如果没有足够代币，可以将代币委托给其他人，代替你提交提案

##### 提案结构

1. 摘要（Abstract）

- - 用两到三句话概括AIP的内容。

1. 动机（Motivation）

- - 说明为什么Arbitrum社区应该实施这个AIP。

1. 理由（Rationale）

- - 解释该AIP如何与Arbitrum社区的使命和指导价值观相符。

1. 关键术语（Key Terms）

- - 对提案中可能包含的特殊术语、Arbitrum社区新引入的术语和/或行业特定的术语进行定义。这个部分是可选的，但推荐包含。

1. 规格（Specifications）

- - 对将使用的平台和技术进行详细拆解。这部分可以详细阐述设计决策的“原因”。此外，还可以描述考虑过的替代设计方案以及相关的工作，例如其他链或语言上类似规格的成功（或失败）实施经验。

1. 实施步骤（Steps to Implement）

- - 详细列出实施AIP的步骤，包括每个步骤的相关费用、所需人力和其他资源（如果适用）。如果AIP涉及与第三方（如资助）进行交易，还需要确保包括适当的法律文件和程序。

1. 时间表（Timeline）

- - 相关的时间细节，包括但不限于开始日期、里程碑和完成日期。

1. 总成本（Overall Cost）

- - 实施AIP的总成本。总成本部分应包括AIP的所有相关费用的拆分，包括每个步骤的费用（如果适用）。应考虑固定成本和经常性成本。

##### 提案前开发

需要更改代码的提案应包括提案通过时将执行的代码。此代码应处理数据结构、逻辑、可执行数据和提案的执行

##### 温度检查

1. **创建提案**：在DAO治理论坛发布提案，使用模板清晰地描述提案的背景、细节、目标与影响。
2. **进行温度检查投票**：在Snapshot平台创建投票，衡量社区对提案的支持度。
3. **社区互动与反馈**：分享投票链接，鼓励社区成员讨论并提出反馈，根据反馈调整提案。
4. **迭代提案**：根据社区的支持与反对意见调整提案，确保其更加完善。
5. **进入链上投票**：如果提案通过温度检查，且获得足够支持，即可进入链上投票阶段。

##### 提交链上提案

1. **登录Tally平台**：使用支持的钱包登录，确保有足够的代币参与提案。
2. **进入Arbitrum DAO页面**：在Tally平台中选择Arbitrum DAO，进入治理管理区域。
3. **创建新提案**：选择合适的提案类型（宪法提案或非宪法提案）。
4. **命名和描述提案**：填写提案标题和详细描述，并可以添加预览图像。
5. **明确执行操作**：列出提案通过后的具体执行步骤。
6. **预览并保存草稿**：检查提案内容，确认无误后保存草稿或直接提交。
7. **提交提案并等待投票**：提案提交后，社区成员进行链上投票，满足支持条件后将执行。
8. **提案结果**：如果通过，提案中的操作将执行；若未通过，可根据反馈修改并重新提交。

### 2024.12.19

#### 治理理念

1. **去中心化治理**：$ARB 代币持有者能够参与决策过程。每个代币持有者的投票权重与他们持有的 $ARB 数量成正比，确保了社区成员的直接影响力。
2. **治理平台**：Arbitrum DAO 的治理智能合约运行在 **Arbitrum One** 网络上，这是以太坊的第二层扩展解决方案，使得整个治理过程既高效又成本较低。
3. **财政管理**：DAO 拥有内置的财政系统，资金用于支持 Arbitrum 的技术开发和维护。代币持有者可以提案并投票决定如何使用这些资金，确保资金使用符合社区利益。
4. **安全机制**：Arbitrum DAO 还包含一个重要的安全委员会机制，该委员会负责应对紧急安全问题。委员会成员通过每半年选举产生，并在必要时有权限绕过常规的投票过程以采取紧急行动。
5. **社区参与和影响力**：通过参与 Arbitrum DAO 的治理过程，$ARB 代币持有者能够直接影响 Arbitrum 网络及其技术的未来发展。这种去中心化治理结构不仅有助于推动 Arbitrum 网络的成长，也对整个以太坊生态系统的未来产生深远影响。

总结来说，Arbitrum DAO 是一个真正的去中心化治理机构，能够让社区成员通过参与提案、投票和资金管理来影响和塑造 Arbitrum 生态系统的未来发展。

### 2024.12.20

#### Bit Coin-数据结构

**指针**：指向结构体在内存中的位置

**Hash 指针**：不仅指向结构体在内存中的位置，而且还保存结构体的 Hash 值（此 Hash 值是由区块的所有内容，包括区块持有的 Hash 指针生成）



区块链就是使用 Hash 指针的链表（链表的头节点被称为创世区块（genesis block））

后续的每一个区块，都持有上一个区块的 Hash 指针，固中途任一一个区块发生改变，后续所有区块都会发生变化



**Merkle Tree**（默克尔树）

使用 Hash 指针的二叉树



每个区块内部就是 Merkle Tree ，每个叶子节点保存了一笔交易，非叶子节点持有左右子节点的 Hash 值。



**Merkle Proof**

轻节点（只保存 Header）向全节点（Header、Body 都存）请求，拿到证明路径上另一半的交易的 Hash 值，然后层层计算，将最终结果与根 Hash 值比对，如果相等，则证明交易有效

### 2024.12.21

#### Bit Coin-协议

双花攻击（double spending attack）：同一个币，花两次



有两种 Hash 指针，一种是指向前一个区块，形成区块链

一种是指向交易的来源（防止双花攻击、证明交易的合法性）



一个交易，分输入和输出两部分

输入部分：指向交易的 Hash 指针，付款人的公钥

输出部分：收款人的公钥



Block Header 组成部分：

1. version 协议版本
2. hash of pervious block header 前一个区块块头的 hash 值
3. mercle root hash 默克尔树的根 Hash 值
4. target 挖矿难度阈值
5. nonce 随机数



Block Body 组成部分：

1. transaction list 交易列表



共识协议

以算力来进行投票



组装候选区块，找到满足要求的 nonce 值，就代表该区块获得 BitCoin 的记账权，有记账权的区块才有权力发布下一个区块



交易必须在最长合法链上，才视为有效；临时分叉，会等待某一分叉胜出

### 2024.12.22

#### Bit Coin-实现

btc 是基于交易的账本

全节点都会维护一个数据结构，utxo（unspend transaction output），用于检查双花攻击

为了促使节点维护交易记录，每次交易都会扣除一定的 gas 费给区块的所有者



区块链每隔21w个区块，区块的出块奖励就会减半，（平均出块时间10min，减半周期大概4年）

btc 总量：2100w个

### 2024.12.23

#### Bit Coin -网络

应用层：bit coin 区块链

网络层：p2p网络（所有节点都是平等的，通过 tcp 通信）



设计原则：简单、健壮，但性能不高

节点使用泛洪的方式向邻居节点发送通知，但是邻居节点的选取是随机的，并不以现实的网络拓扑为依据

#### Bit Coin-挖矿难度

H(block_header) <= target

bit coin 的 hash 算法是 sha-256



阈值调整公式：

target = target * actual time(系统生成最近2016个区块花费的时间) / expected time(系统预计生成2016个区块花费的时间)

### 2024.12.24

##### Bit Coin-挖矿

挖矿设备：普通cpu   =》 gpu  =》  asic（专用挖矿芯片）



单机挖矿  =》 矿池挖矿

矿池管理者来打包交易，手下矿工负责计算 hash 值

单矿工收益不稳定，矿池挖矿收益稳定，可平分收益



数据中心式挖矿：一人拥有很多台矿机

分布式挖矿：按矿主规定的通讯协议来分布式挖矿，矿主会把需要计算的 hash 值发送给各地的矿工，矿工计算完之后，将结果发给矿主，后续有奖励的时候，矿工可参与分红



利益分配方式：按算力多少来分配利益 -> pow（proof of work）

挖到差不多符合要求的区块后，把区块提交给矿主，等到以后真正有矿工挖到符合要求的区块后，前面这些大致符合要求的区块将作为工作量的证明，参与利益分配

### 2024.12.25

#### Bit Coin-分叉

state fork（状态分叉）：两个节点同时挖到符合条件的区块，链上就会有暂时性的分叉

forking attack（分叉攻击）也属于 state fork



protocol fork （协议分叉）：协议发生改变而导致的分叉

根据协议修改的内容不同，可分为硬分叉和软分叉



hard fork（硬分叉）：对之后的区块做扩展

eg: 区块大小限制变大，假设大多数人更新软件，使区块变大；链上同时挖出大区块和小区块，大区块同时认可小区块和大区块，但大部分算力在大区块这里，大区块会沿着大区块链往后继续挖；小区块只认可小区块，所以小区块只会沿着小区块继续向下挖，链就永久性分叉了。



soft fork（软分叉）：对之后的区块做限制

eg: 区块大小限制变小，假设大多数人更新软件，使区块变小；链上同时挖出大区块和小区块，大区块同时认可小区块和大区块，大区块可以两边挖；小区块只认可小区块，所以小区块只会沿着小区块继续向下挖，由于大部分算力在小区块这边，新旧节点都会在小区块这条链上继续挖。

### 2024.12.26

#### Bit Coin-匿名性

比特币交易不要求使用真名，只需要使用公钥地址，所以具有一定的匿名性。但不是完全的匿名（anonymity），而是类似网名、笔名的一种化名（pseudonymity），而不是真的匿名。



和纸币相比，比特币的匿名性没有纸币高，因为纸币是完全不记录使用者名字的。但是对于大额的交易中，使用纸币不便于运输。

和现在的银行相比，银行办理账户时需要去银行提交身份信息，而比特币建立账户不需要任何审批。这点比特币比银行匿名性高。

但是，在银行办理可以用化名办理存折的时代，银行的匿名性是要比比特币更高的。因为比特币的所有转账交易都是在区块链里公开的，所有人都可以看到。而银行的转账交易只有银行内部人员、司法等特殊人员才可以查询到。

##### 可能会破坏匿名性的地方

###### 比特币交易中的账户关联

虽然一个人可以有n多个账户，但是这些账户在某些情况下是可以被关联起来的。



例如在一个交易中，有3个输入、2个输出：这3个输入很可能是同一个人的，因为他同时有这3个账户的私钥做签名，可能因为一个账户中的金额不够，所以把3个账户的金额加一起才够。在这2个输出中，可能一个输出是商家的，另一个输出也是购买者本人的。前面输入的金额一般不会正好等于货款，输入的金额多于货款时，购买者用自己的另一个账户做输出，用于“找零钱”操作。这种操作一般都是比特币钱包生成的，比特币钱包在找零时会自动生成一个新的账户，也是为了隐私保护。



假设一个交易中：账户A转出4 BTC，账户B转出 5 BTC，账户C收到 6 BTC ，账户D收到 3 BTC。那么就可以分析出，账户A、账户B、账户D是同一个人的。

###### 比特币和现实世界中的关联

当用比特币在现实中购买货物时，需要提供收货人信息。或者有些实体店接受比特币支付，这时用于支付的账户也会和现实中的这个人建立联系。也会造成隐私破坏。



当在比特币交易所使用法币和比特币进行兑换时，在交易所开户需要提供个人信息。

如果是进行的“场外交易”（不经过交易所，直接和有比特币的人联系），使用法币和比特币进行兑换，交易对手也会得到购买者的一部分信息。



###### 大笔金额的比特币交易

对于很大笔的比特币的转入、转出交易，很可能引起相关司法部门的调查洗钱嫌疑。这时比特币的隐私也可能被破坏。

### 2024.12.27

##### 网络的匿名性

###### 网络层面的匿名性

比特币是运行在应用层的，底层是P2P的网络层。如果在网络层不能保证匿名性，其他节点发现很多交易都来自某个节点，根据这个节点数据包的IP等信息就可以很容易找到物理世界中的这个人。



网络层面的匿名性在学术界已经有了很好的解决方案，比较普遍的就是利用多路径转发的方法，例如使用TOR（洋葱路由）。消息不是sender直接发给receiver，而是中间经过很多“跳”进行转发，中间的每个转发的节点只知道它的上一个节点是谁，但是并不知道该消息最早是谁发出的。

###### 应用层的匿名性

将不同人的比特币混在一起，使其他人分辨不出谁是谁，无法通过交易关联。这种方式称为coin mixing。



有一些专门做coin mixing的网站，收取一定的服务费，将自己的币交给这个网站，这个网站将很多人的币进行混合重组，最后再转回来。但是转回来时候的币已经不再是输入时候的币了。

coin mixing实际实施起来比较复杂，如果coin mixing设计的不好，可能根据当时存入的数额推断出哪些币是当初存进去的。

更重要的，在区块链世界里，没有信誉度非常高的coin mixing服务。很多coin mixing 服务本身也是匿名的，如果coin mixing服务商把自己投入的币卷款跑路了，自己实际上一点办法也没有。



有时我们不一定要刻意去做coin mixing，有一些应用本身带有coin mixing的性质，例如在线钱包。

在线钱包需要很多人把币存进去，最后自己需要取出来的时候，取出的可能就不是当时自己存入的币了。但是在线钱包并不保证要履行 coin mixing 的功能。

另外，一般来说，加密货币的交易所也天然的具有coin mixing性质。但是有个前提，这个交易所不会泄露这些提币、存币的记录。

### 2024.12.28

#### 零知识证明

零知识证明，是指一方（证明者）向另一方（验证者）证明一个陈述是正确的，而无需透露除该陈述是正确的之外的任何信息。

例如，在比特币交易中，需要证明自己拥有该公钥对应的私钥，但是又不能将自己的私钥公布出去。证明者可以使用该私钥制作一个签名，验证者可以通过证明者的公钥验证这个签名的合法性。

#### 同态隐藏

零知识证明的数学基础是同态隐藏。

同态隐藏的三个性质：

- 如果 x，y不同，那么它们的加密函数值 E(x) 和 E(y) 也不相同（即不会出现碰撞）。
  反过来，如果两个加密函数值E(x) = E(y) ，那么加密前的两个输入值 x = y。

- 给定 E(x) 的值，很难反推出x的值（即不可逆性）。

- 给定 E(x) 和 E(y) 的值，我们可以很容易的计算出某些关于x，y的加密函数值： 

- - 同态加法：通过 E(x) 和 E(y) 能够计算出 E(x+y) 的值

- - 同态乘法：通过 E(x) 和 E(y) 能够计算出 E(xy) 的值

- - 扩展列多项式



例如：Alice想要向Bob证明她知道一组数x和y使得 x + y = 7，但是同时又不让Bob知道x和y的具体数值。

操作方式：

- Alice把 E(x) 和 E(y) 的数值发送给Bob（同态隐藏性质2）

- Bob通过收到的 E(x) 和 E(y) 计算出 E(x+y) 的值（同态隐藏的性质3）。

- Bob同时计算 E(7) 的值，如果 E(x+y) = E(7)，那么验证通过，否则验证失败（同态隐藏性质1）。



在实际操作中，虽然以上方式没有将x、y透漏给Bob，但是Bob可能通过蛮力方式遍历x、y的数值，和E(x)、E(y)验证，从而获取到x、y的具体值。所以如果想要安全，Alice在将E(x)、E(y)送给Bob前，需要对输入做一些随机化的处理，同时要保证处理过后的 x+y=7。

### 2024.12.29

#### 盲签

盲签方法：

- 用户A生成一个流水号SerialNum，银行在不知道SerialNum的情况下返回签名Token，减少A的存款

- 用户A把SerialNum和Token交给B完成交易

- 用户B拿着SerialNum和Token给银行验证，银行验证通过，增加B的存款

- 银行无法把A和B联系起来

- 中心化



#### 零币和零钞

零币和零钞在协议层就融合了匿名化处理，其匿名属性来自密码学保证。

零币（zerocoin）系统中存在基础币和零币，通过基础币和零币的来回转换，消除旧地址和新地址的关联性，其原理类似于混币服务。

零钞（zerocash）系统使用 zk-SHARKs 协议，不依赖一种基础币，区块链中只记录交易的存在性和矿工用来验证系统正产运行所需要关键属性的证明。区块链上既不显示交易地址也不显示交易金额，所有交易通过零知识验证的方式进行。



### 2024.12.30

#### Bit Coin-总结

1. 哈希指针与区块链结构：比特币区块链使用哈希指针来链接区块，确保数据不可篡改和安全性。每个区块通过哈希值引用前一个区块，从而形成不可更改的链条。
2. 私钥管理：私钥用于控制比特币账户的资金。多方共同管理账户时，通过分割私钥可能带来安全风险，推荐使用多重签名机制来提高安全性。
3. 分布式共识与矿工：比特币的工作量证明机制虽然实现了分布式共识，但共识并非绝对可靠，可能受到攻击或回滚影响。分布式系统面临一些理论上的限制，但实际应用中通过适当调整可克服。
4. 比特币的稀缺性：比特币的总量限制（2100万枚）使其具备稀缺性，但这种设计可能不利于其作为货币的长期使用，因为缺乏适度的通货膨胀机制。
5. 量子计算的威胁：量子计算可能威胁现有的加密算法，但比特币系统可以通过技术升级来适应这一挑战。尽管如此，量子计算对比特币的威胁暂时较小。

<!-- Content_END -->
